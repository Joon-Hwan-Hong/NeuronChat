vertex.size.max
vertex.weight[names(V(g))]
color.use = NULL;title.name = NULL; sources.use = NULL; targets.use = NULL; remove.isolate = FALSE; top = 1;
weight.scale = TRUE; vertex.weight = 1; vertex.weight.max = NULL; vertex.size.max = NULL; vertex.label.cex=1;vertex.label.color= "black";
edge.weight.max = NULL; edge.width.max=5; alpha.edge = 0.6; label.edge = FALSE;edge.label.color='black';edge.label.cex=0.8;
edge.curved=0.2;shape='circle';layout=in_circle(); margin=0.2; vertex.size = NULL;
arrow.width=1;arrow.size = 0.2
net.names <- unique(c(rownames(net_ori),colnames(net_ori)))
net <- matrix(0,nrow=length(net.names),ncol=length(net.names))
dimnames(net) <- list(net.names,net.names)
net[rownames(net_ori),colnames(net_ori)] <- net_ori
if (!is.null(vertex.size)) {
warning("'vertex.size' is deprecated. Use `vertex.weight`")
}
if (is.null(vertex.size.max)) {
if (length(unique(vertex.weight)) == 1) {
vertex.size.max <- 5
} else {
vertex.size.max <- 15
}
}
vertex.weight
if ((!is.null(sources.use)) | (!is.null(targets.use))) {
if (is.null(rownames(net))) {
stop("The input weighted matrix should have rownames!")
}
cells.level <- rownames(net)
df.net <- reshape2::melt(net, value.name = "value")
colnames(df.net)[1:2] <- c("source","target")
# keep the interactions associated with sources and targets of interest
if (!is.null(sources.use)){
if (is.numeric(sources.use)) {
sources.use <- cells.level[sources.use]
}
df.net <- subset(df.net, source %in% sources.use)
}
if (!is.null(targets.use)){
if (is.numeric(targets.use)) {
targets.use <- cells.level[targets.use]
}
df.net <- subset(df.net, target %in% targets.use)
}
df.net$source <- factor(df.net$source, levels = cells.level)
df.net$target <- factor(df.net$target, levels = cells.level)
df.net$value[is.na(df.net$value)] <- 0
net <- tapply(df.net[["value"]], list(df.net[["source"]], df.net[["target"]]), sum)
}
vertex.weight
net[is.na(net)] <- 0
if (remove.isolate) {
idx1 <- which(Matrix::rowSums(net) == 0)
idx2 <- which(Matrix::colSums(net) == 0)
idx <- intersect(idx1, idx2)
net <- net[-idx, ]
net <- net[, -idx]
}
g1 <- graph_from_adjacency_matrix(net, mode = "directed", weighted = T)
if (is.null(group)) {
g <-igraph::permute(g1,match(V(g1)$name,net.names))
group <- structure(rep(1,length(V(g))),names=names(V(g)))
group <- group[names(V(g))]
} else {
g <-igraph::permute(g1,match(V(g1)$name,names(group)[order(group, names(group))]))
}
edge.start <- igraph::ends(g, es=igraph::E(g), names=FALSE)
coords<-layout_(g,layout)
if(nrow(coords)!=1){
coords_scale=scale(coords)
}else{
coords_scale<-coords
}
if (is.null(color.use)) {
color.use = CellChat::scPalette(length(igraph::V(g)))
}
if (is.null(vertex.weight.max)) {
vertex.weight.max <- max(vertex.weight)
}
vertex.weight
vertex.weight.max
vertex.size.max
vertex.weight <- vertex.weight/vertex.weight.max*vertex.size.max+5
vertex.weight
vertex.weight
color.use = NULL;title.name = NULL; sources.use = NULL; targets.use = NULL; remove.isolate = FALSE; top = 1;
weight.scale = TRUE; vertex.weight = 1; vertex.weight.max = NULL; vertex.size.max = NULL; vertex.label.cex=1;vertex.label.color= "black";
edge.weight.max = NULL; edge.width.max=5; alpha.edge = 0.6; label.edge = FALSE;edge.label.color='black';edge.label.cex=0.8;
edge.curved=0.2;shape='circle';layout=in_circle(); margin=0.2; vertex.size = NULL;
arrow.width=1;arrow.size = 0.2
net.names <- unique(c(rownames(net_ori),colnames(net_ori)))
net <- matrix(0,nrow=length(net.names),ncol=length(net.names))
dimnames(net) <- list(net.names,net.names)
net[rownames(net_ori),colnames(net_ori)] <- net_ori
if (!is.null(vertex.size)) {
warning("'vertex.size' is deprecated. Use `vertex.weight`")
}
if (is.null(vertex.size.max)) {
if (length(unique(vertex.weight)) == 1) {
vertex.size.max <- 5
} else {
vertex.size.max <- 15
}
}
options(warn = -1)
thresh <- stats::quantile(net, probs = 1-top)
net[net < thresh] <- 0
if ((!is.null(sources.use)) | (!is.null(targets.use))) {
if (is.null(rownames(net))) {
stop("The input weighted matrix should have rownames!")
}
cells.level <- rownames(net)
df.net <- reshape2::melt(net, value.name = "value")
colnames(df.net)[1:2] <- c("source","target")
# keep the interactions associated with sources and targets of interest
if (!is.null(sources.use)){
if (is.numeric(sources.use)) {
sources.use <- cells.level[sources.use]
}
df.net <- subset(df.net, source %in% sources.use)
}
if (!is.null(targets.use)){
if (is.numeric(targets.use)) {
targets.use <- cells.level[targets.use]
}
df.net <- subset(df.net, target %in% targets.use)
}
df.net$source <- factor(df.net$source, levels = cells.level)
df.net$target <- factor(df.net$target, levels = cells.level)
df.net$value[is.na(df.net$value)] <- 0
net <- tapply(df.net[["value"]], list(df.net[["source"]], df.net[["target"]]), sum)
}
net[is.na(net)] <- 0
if (remove.isolate) {
idx1 <- which(Matrix::rowSums(net) == 0)
idx2 <- which(Matrix::colSums(net) == 0)
idx <- intersect(idx1, idx2)
net <- net[-idx, ]
net <- net[, -idx]
}
g1 <- graph_from_adjacency_matrix(net, mode = "directed", weighted = T)
if (is.null(group)) {
g <-igraph::permute(g1,match(V(g1)$name,net.names))
group <- structure(rep(1,length(V(g))),names=names(V(g)))
group <- group[names(V(g))]
} else {
g <-igraph::permute(g1,match(V(g1)$name,names(group)[order(group, names(group))]))
}
edge.start <- igraph::ends(g, es=igraph::E(g), names=FALSE)
coords<-layout_(g,layout)
if(nrow(coords)!=1){
coords_scale=scale(coords)
}else{
coords_scale<-coords
}
if (is.null(color.use)) {
color.use = CellChat::scPalette(length(igraph::V(g)))
}
if (is.null(vertex.weight.max)) {
vertex.weight.max <- max(vertex.weight)
}
vertex.weight <- vertex.weight/vertex.weight.max*vertex.size.max+5
# color.use.label  <- c('red','black')
color.use.label <- c('black',CellChat::scPalette(length(unique(group))))[1:length(unique(group))]
color.use.label <- structure(color.use.label,names=unique(group))
# color.use.label <- color.use.label[-length(color.use.label)]
# if(length(color.use.label)==1){ color.use.label='black'}
loop.angle<-ifelse(coords_scale[igraph::V(g),1]>0,-atan(coords_scale[igraph::V(g),2]/coords_scale[igraph::V(g),1]),pi-atan(coords_scale[igraph::V(g),2]/coords_scale[igraph::V(g),1]))
if(length(vertex.weight)==1){ igraph::V(g)$size<-vertex.weight} else {igraph::V(g)$size<-vertex.weight[names(V(g))]}
igraph::V(g)$color<-color.use[igraph::V(g)]
igraph::V(g)$shape <- c('circle')#, 'square', 'csquare', 'rectangle', 'crectangle', 'vrectangle', 'pie', 'raster','sphere')[group[igraph::V(g)]]
igraph::V(g)$frame.color <- color.use[igraph::V(g)]
#igraph::V(g)$frame.color <- border.color.use[igraph::V(g)]
igraph::V(g)$label.color <-color.use.label[group[names(V(g))]]#unlist(lapply(V(g), FUN= function(x){color.use.label[group[x]]}))
igraph::V(g)$label.cex<-vertex.label.cex
if(label.edge){
igraph::E(g)$label<-igraph::E(g)$weight
igraph::E(g)$label <- round(igraph::E(g)$label, digits = 1)
}
if (is.null(edge.weight.max)) {
edge.weight.max <- max(igraph::E(g)$weight)
}
if (weight.scale == TRUE) {
#E(g)$width<-0.3+edge.width.max/(max(E(g)$weight)-min(E(g)$weight))*(E(g)$weight-min(E(g)$weight))
igraph::E(g)$width<- 0.3+igraph::E(g)$weight/edge.weight.max*edge.width.max
}else{
igraph::E(g)$width<-0.3+edge.width.max*igraph::E(g)$weight
}
igraph::E(g)$arrow.width<-arrow.width
igraph::E(g)$arrow.size<-arrow.size
igraph::E(g)$label.color<-edge.label.color
igraph::E(g)$label.cex<-edge.label.cex
igraph::E(g)$color<- grDevices::adjustcolor(igraph::V(g)$color[edge.start[,1]],alpha.edge)
if(sum(edge.start[,2]==edge.start[,1])!=0){
igraph::E(g)$loop.angle[which(edge.start[,2]==edge.start[,1])]<-loop.angle[edge.start[which(edge.start[,2]==edge.start[,1]),1]]
}
radian.rescale <- function(x, start=0, direction=1) {
c.rotate <- function(x) (x + start) %% (2 * pi) * direction
c.rotate(scales::rescale(x, c(0, 2 * pi), range(x)))
}
label.locs <- radian.rescale(x=1:length(igraph::V(g)), direction=-1, start=0)
label.dist <- vertex.weight/max(vertex.weight)+4
plot(g,edge.curved=edge.curved,layout=coords_scale,margin=margin, vertex.label.dist=label.dist,
vertex.label.degree=label.locs, vertex.label.family="Helvetica", edge.label.family="Helvetica") # "sans"
# plot(g,edge.curved=edge.curved,layout=coords_scale,margin=margin, vertex.label.dist=label.dist,
#      vertex.label.degree=label.locs, vertex.label.family="Helvetica", edge.label.family="Helvetica",vertex.label="") # "sans"
# ## https://gist.github.com/ajhmohr/5337a5c99b504e4a243fad96203fa74f
# text.pos <- coords*(1.15+strwidth(names(V(g)),font=12)/2)
# angle = ifelse(atan(-(coords[,1]/coords[,2]))*(180/pi) < 0,  90 + atan(-(coords[,1]/coords[,2]))*(180/pi), 270 + atan(-coords[,1]/coords[,2])*(180/pi))
# for (i in 1:length(V(g))) {
#   text(x=text.pos[i,1], y=text.pos[i,2], labels=V(g)$name[i], adj=NULL, pos=NULL, cex=1.2, col=igraph::V(g)$label.color[i], srt=angle[i], xpd=T)
# }
if (!is.null(title.name)) {
text(0,1.6,title.name, cex = 1.5)
}
# https://www.andrewheiss.com/blog/2016/12/08/save-base-graphics-as-pseudo-objects-in-r/
# grid.echo()
# gg <-  grid.grab()
gg <- recordPlot()
gg
library(NeuronChat)
netVisual_circle_neuron(net_aggregated_x,group=group)
netVisual_circle_neuron(net_aggregated_x)#,group=group)
netVisual_circle_neuron(net_aggregated_x,vertex.label.cex = 0.5)#,group=group)
netVisual_circle_neuron(net_aggregated_x,,group=group,vertex.label.cex = 1)
netVisual_chord_neuron(x,method = 'weight',group=group)
netVisual_chord_neuron(x,method = 'weight',group=group,lab.cex = 0.5)
netVisual_chord_neuron(x,method = 'weight',group=group,lab.cex = 1)
CellChat::netVisual_chord_cell_internal(net_aggregated_x, group = group,lab.cex=1)
netVisual_circle_neuron(net_aggregated_x,,group=group,vertex.label.cex = 1)
heatmap_single(x,interaction_name='Glu_Gria2',group=group)
heatmap_aggregated(x, interaction_name='Glu_Gria2',group=group)
heatmap_aggregated(x,group=group)
View(heatmap_aggregated)
library(NeuronChat)
heatmap_aggregated(x, method='weight',group=group)
?knitr::opts_chunk$set
?knitr::opts_chunk
netVisual_circle_neuron(x@net$Glu_Gria2,group=group,vertex.label.cex = 1)
netVisual_chord_neuron(x,interaction_use='Glu_Gria2',group=group,lab.cex = 1)
netVisual_chord_neuron(x,method = 'weight',group=group,lab.cex = 1)
CellChat::netVisual_chord_cell_internal(net_aggregated_x, group = group,lab.cex=1)
NeuronChat::netVisual_chord_neuron(x,method = 'weight',group=group,lab.cex = 1)
# Visualization for the single interaction pair, circle plot
netVisual_circle_neuron(x@net$Glu_Gria2,group=group,vertex.label.cex = 1)
# Visualization for the single interaction pair, heatmap
netVisual_chord_neuron(x,interaction_use='Glu_Gria2',group=group,lab.cex = 1)
# Visualization for the single interaction pair, heatmap
heatmap_single(x,interaction_name='Glu_Gria2',group=group)
# Visualization for the single interaction pair, circle plot
netVisual_circle_neuron(x@net$Glu_Gria2,group=group,vertex.label.cex = 1)
# Visualization for the single interaction pair, heatmap
netVisual_chord_neuron(x,interaction_use='Glu_Gria2',group=group,lab.cex = 1)
# Visualization for the single interaction pair, heatmap
heatmap_single(x,interaction_name='Glu_Gria2',group=group)
lig_tar_heatmap(x,interaction_name='Glu_Gria2',group=group)
lig_tar_heatmap(x,interaction_name='Glu_Gria2')
View(lig_tar_heatmap)
library(NeuronChat)
lig_tar_heatmap(x,interaction_name='Glu_Gria2')
library(NeuronChat)
lig_tar_heatmap(x,interaction_name='Glu_Gria2')
library(NeuronChat)
# load example data: cortex data from Yao 2021, processed
data(list='cortex_data')
# subset the data by choosing the region VISp
region_name <- 'VISp'; cell_class <- names(table(meta$class_label))
cell_idx <- which(meta$region_label %in% region_name & meta$class_label %in% cell_class & !(meta$subclass_label %in%c('Car3','CR','DG','L2/3 IT PPP','L5/6 IT TPE-ENT')))
target_df_single  <- target_df[cell_idx,] # a data frame: row  cell, column gene (the last column is the cell subclass)
meta_tmp <- meta[cell_idx,];rownames(meta_tmp) <- meta_tmp$sample_name # subset meta
df_group <- meta_tmp[!duplicated(meta_tmp$subclass_label),c('class_label','subclass_label')]
group <- structure(df_group$class_label,names=df_group$subclass_label) # create the cell class for the subclasses, used for plot
# creat NeuronChat object; choose the database 'mouse' for mouse data; 'human' for human data
# note that the first parameter should be a numeric matrix with row gene and column cell
x <- createNeuronChat(t(as.matrix(target_df_single[,1:(dim(target_df_single)[2]-1)])),DB='mouse',group.by = target_df_single$cell_subclass);
# run NeuronChat to infer the neural-specific cell-cell communication networks
# M is for the permutation test; typically ~4 mins when M=100, depending on the dataset size and the number of cell groups
# setting M=10 to get a quick start
x <- run_NeuronChat(x,M=2)
# aggregate the communication networks over all interaction pairs, method can be 'weight', 'count' and so on
# the the communication networks for individual interaction pairs are stored in slot 'net'
net_aggregated_x <- net_aggregation(x@net,method = 'weight')
# Visualization, circle plot, for the aggregated network
netVisual_circle_neuron(net_aggregated_x,group=group,vertex.label.cex = 1)
# Visualization, chordDiagram, for the aggregated network
netVisual_chord_neuron(x,method = 'weight',group=group,lab.cex = 1)
# Visualization, chordDiagram using cellchat function netVisual_chord_cell_internal(net_aggregated_x, group = group,lab.cex=1)
# Visualization, heatmap for the aggregated network
heatmap_aggregated(x, method='weight',group=group)
# Visualization for the single interaction pair, circle plot
netVisual_circle_neuron(x@net$Glu_Gria2,group=group,vertex.label.cex = 1)
# Visualization for the single interaction pair, heatmap
netVisual_chord_neuron(x,interaction_use='Glu_Gria2',group=group,lab.cex = 1)
# Visualization for the single interaction pair, heatmap
heatmap_single(x,interaction_name='Glu_Gria2',group=group)
```{r fig1, fig.height = 4, fig.width = 15}
x
?lig_tar_heatmap
View(lig_tar_heatmap)
library(NeuronChat)
library(NeuronChat)
?VlnPlot
object; interaction_name;width.vector=c(0.3,0.34,0.31); sender.names=NULL; receiver.names=NUL
object <- x
if(is.null(sender.names)){sender.names=rownames(object@net[[1]])}
if(is.null(receiver.names)){receiver.names=colnames(object@net[[1]])}
## create Seurat object from NeuronChat object
meta <- data.frame(cell_subclass=object@data.signaling$cell_subclass)
rownames(meta) <- rownames(object@data.signaling)
seurat_VISp <- Seurat::CreateSeuratObject(counts = object@data, meta.data = meta)
seurat_VISp$groups <- meta$cell_subclass
SeuratObject::Idents(seurat_VISp) <- meta$cell_subclass
levels(seurat_VISp) <- sort(unique(c(sender.names,receiver.names)),method='radix')
## plot #1: heatmap
col_map = colorRamp2(c(0,max(object@net[[interaction_name]][sender.names,receiver.names])/2, max(object@net[[interaction_name]][sender.names,receiver.names])), c("blue", "white", "red"))
column_ha = HeatmapAnnotation(target = anno_barplot(object@target.abundance[receiver.names,interaction_name],border = F,height = unit(2,'cm'),gp = gpar(fill = "lightskyblue1")),annotation_name_side='left',annotation_name_rot = 0,annotation_label = 'target \n abundance')
row_ha = rowAnnotation(ligand = anno_barplot(object@ligand.abundance[sender.names,interaction_name],border = F,width = unit(2,'cm'),gp = gpar(fill = "lightskyblue1")),annotation_label = 'ligand \n abundance')
h1 <- ComplexHeatmap::Heatmap(object@net[[interaction_name]][sender.names,receiver.names], name = "Commu. \n Prob.", top_annotation = column_ha, right_annotation = row_ha,
cluster_rows = F,cluster_columns = F,column_names_rot=45,row_names_side = 'left',col = col_map,
column_title = 'Receiver',row_title = 'Sender',column_title_side = 'bottom',
heatmap_legend_param = list(color_bar='continuous'),show_row_dend = FALSE)
## plot #2: expression level for ligand related genes
if(length(object@DB[[interaction_name]]$lig_contributor)>1){
p1 <- Seurat::VlnPlot(subset(seurat_VISp, idents = sender.names),features = object@DB[[interaction_name]]$lig_contributor,group.by = 'cell_subclass',pt.size = 0,stack = T,flip = T)
p1$labels$title <- c('Ligand genes')} else {
p1 <- Seurat::VlnPlot(subset(seurat_VISp, idents = sender.names),features = object@DB[[interaction_name]]$lig_contributor,group.by = 'cell_subclass',pt.size = 0)+ theme(legend.position = 'none')
p1$labels$title <- paste('Ligand gene: ',p1$labels$title)
}
p1$theme$plot.title$hjust <- 0.5
## plot #3: expression level for ligand related genes
p2 <- Seurat::VlnPlot(subset(seurat_VISp, idents = receiver.names),features = object@DB[[interaction_name]]$receptor_subunit,group.by = 'cell_subclass',pt.size = 0) + theme(legend.position = 'none')
p2$labels$title <- paste('Target gene: ',p2$labels$title)
gb_h1 <- grid.grabExpr(draw(h1))
gb_p1 <- grid.grabExpr(print(p1))
gb_p2 <- grid.grabExpr(print(p2))
grid.newpage()
pushViewport(viewport(x = 0, y = 1, width = width.vector[1]-0.02, height =1, just = c("left", "top"),xscale=c(0,1),yscale = c(0,1)))
grid.draw(gb_h1);popViewport()
pushViewport(viewport(x = width.vector[1], y = 1, width = width.vector[2]-0.02, height = 1,just = c("left", "top"),xscale=c(0,1),yscale = c(0,1)))
grid.draw(gb_p1);popViewport()
pushViewport(viewport(x = width.vector[1]+width.vector[2], y = 1, width = width.vector[3]-0.02, height = 1,just = c("left", "top"),xscale=c(0,1),yscale = c(0,1)))
grid.draw(gb_p2);popViewport()
interaction_name='Glu_Gria2';width.vector=c(0.36,0.3,0.3)
if(is.null(sender.names)){sender.names=rownames(object@net[[1]])}
if(is.null(receiver.names)){receiver.names=colnames(object@net[[1]])}
## create Seurat object from NeuronChat object
meta <- data.frame(cell_subclass=object@data.signaling$cell_subclass)
rownames(meta) <- rownames(object@data.signaling)
seurat_VISp <- Seurat::CreateSeuratObject(counts = object@data, meta.data = meta)
seurat_VISp$groups <- meta$cell_subclass
SeuratObject::Idents(seurat_VISp) <- meta$cell_subclass
levels(seurat_VISp) <- sort(unique(c(sender.names,receiver.names)),method='radix')
## plot #1: heatmap
col_map = colorRamp2(c(0,max(object@net[[interaction_name]][sender.names,receiver.names])/2, max(object@net[[interaction_name]][sender.names,receiver.names])), c("blue", "white", "red"))
column_ha = HeatmapAnnotation(target = anno_barplot(object@target.abundance[receiver.names,interaction_name],border = F,height = unit(2,'cm'),gp = gpar(fill = "lightskyblue1")),annotation_name_side='left',annotation_name_rot = 0,annotation_label = 'target \n abundance')
row_ha = rowAnnotation(ligand = anno_barplot(object@ligand.abundance[sender.names,interaction_name],border = F,width = unit(2,'cm'),gp = gpar(fill = "lightskyblue1")),annotation_label = 'ligand \n abundance')
h1 <- ComplexHeatmap::Heatmap(object@net[[interaction_name]][sender.names,receiver.names], name = "Commu. \n Prob.", top_annotation = column_ha, right_annotation = row_ha,
cluster_rows = F,cluster_columns = F,column_names_rot=45,row_names_side = 'left',col = col_map,
column_title = 'Receiver',row_title = 'Sender',column_title_side = 'bottom',
heatmap_legend_param = list(color_bar='continuous'),show_row_dend = FALSE)
## plot #2: expression level for ligand related genes
if(length(object@DB[[interaction_name]]$lig_contributor)>1){
p1 <- Seurat::VlnPlot(subset(seurat_VISp, idents = sender.names),features = object@DB[[interaction_name]]$lig_contributor,group.by = 'cell_subclass',pt.size = 0,stack = T,flip = T)
p1$labels$title <- c('Ligand genes')} else {
p1 <- Seurat::VlnPlot(subset(seurat_VISp, idents = sender.names),features = object@DB[[interaction_name]]$lig_contributor,group.by = 'cell_subclass',pt.size = 0)+ theme(legend.position = 'none')
p1$labels$title <- paste('Ligand gene: ',p1$labels$title)
}
p1$theme$plot.title$hjust <- 0.5
## plot #3: expression level for ligand related genes
p2 <- Seurat::VlnPlot(subset(seurat_VISp, idents = receiver.names),features = object@DB[[interaction_name]]$receptor_subunit,group.by = 'cell_subclass',pt.size = 0) + theme(legend.position = 'none')
p2$labels$title <- paste('Target gene: ',p2$labels$title)
gb_h1 <- grid.grabExpr(draw(h1))
gb_p1 <- grid.grabExpr(print(p1))
gb_p2 <- grid.grabExpr(print(p2))
grid.newpage()
pushViewport(viewport(x = 0, y = 1, width = width.vector[1]-0.02, height =1, just = c("left", "top"),xscale=c(0,1),yscale = c(0,1)))
grid.draw(gb_h1);popViewport()
pushViewport(viewport(x = width.vector[1], y = 1, width = width.vector[2]-0.02, height = 1,just = c("left", "top"),xscale=c(0,1),yscale = c(0,1)))
grid.draw(gb_p1);popViewport()
pushViewport(viewport(x = width.vector[1]+width.vector[2], y = 1, width = width.vector[3]-0.02, height = 1,just = c("left", "top"),xscale=c(0,1),yscale = c(0,1)))
grid.draw(gb_p2);popViewport()
sender.names
sender.names=NULL
receiver.names=NULL
if(is.null(sender.names)){sender.names=rownames(object@net[[1]])}
if(is.null(receiver.names)){receiver.names=colnames(object@net[[1]])}
## create Seurat object from NeuronChat object
meta <- data.frame(cell_subclass=object@data.signaling$cell_subclass)
rownames(meta) <- rownames(object@data.signaling)
seurat_VISp <- Seurat::CreateSeuratObject(counts = object@data, meta.data = meta)
seurat_VISp$groups <- meta$cell_subclass
SeuratObject::Idents(seurat_VISp) <- meta$cell_subclass
levels(seurat_VISp) <- sort(unique(c(sender.names,receiver.names)),method='radix')
## plot #1: heatmap
col_map = colorRamp2(c(0,max(object@net[[interaction_name]][sender.names,receiver.names])/2, max(object@net[[interaction_name]][sender.names,receiver.names])), c("blue", "white", "red"))
column_ha = HeatmapAnnotation(target = anno_barplot(object@target.abundance[receiver.names,interaction_name],border = F,height = unit(2,'cm'),gp = gpar(fill = "lightskyblue1")),annotation_name_side='left',annotation_name_rot = 0,annotation_label = 'target \n abundance')
row_ha = rowAnnotation(ligand = anno_barplot(object@ligand.abundance[sender.names,interaction_name],border = F,width = unit(2,'cm'),gp = gpar(fill = "lightskyblue1")),annotation_label = 'ligand \n abundance')
h1 <- ComplexHeatmap::Heatmap(object@net[[interaction_name]][sender.names,receiver.names], name = "Commu. \n Prob.", top_annotation = column_ha, right_annotation = row_ha,
cluster_rows = F,cluster_columns = F,column_names_rot=45,row_names_side = 'left',col = col_map,
column_title = 'Receiver',row_title = 'Sender',column_title_side = 'bottom',
heatmap_legend_param = list(color_bar='continuous'),show_row_dend = FALSE)
## plot #2: expression level for ligand related genes
if(length(object@DB[[interaction_name]]$lig_contributor)>1){
p1 <- Seurat::VlnPlot(subset(seurat_VISp, idents = sender.names),features = object@DB[[interaction_name]]$lig_contributor,group.by = 'cell_subclass',pt.size = 0,stack = T,flip = T)
p1$labels$title <- c('Ligand genes')} else {
p1 <- Seurat::VlnPlot(subset(seurat_VISp, idents = sender.names),features = object@DB[[interaction_name]]$lig_contributor,group.by = 'cell_subclass',pt.size = 0)+ theme(legend.position = 'none')
p1$labels$title <- paste('Ligand gene: ',p1$labels$title)
}
p1$theme$plot.title$hjust <- 0.5
## plot #3: expression level for ligand related genes
p2 <- Seurat::VlnPlot(subset(seurat_VISp, idents = receiver.names),features = object@DB[[interaction_name]]$receptor_subunit,group.by = 'cell_subclass',pt.size = 0) + theme(legend.position = 'none')
p2$labels$title <- paste('Target gene: ',p2$labels$title)
gb_h1 <- grid.grabExpr(draw(h1))
gb_p1 <- grid.grabExpr(print(p1))
gb_p2 <- grid.grabExpr(print(p2))
grid.newpage()
pushViewport(viewport(x = 0, y = 1, width = width.vector[1]-0.02, height =1, just = c("left", "top"),xscale=c(0,1),yscale = c(0,1)))
grid.draw(gb_h1);popViewport()
pushViewport(viewport(x = width.vector[1], y = 1, width = width.vector[2]-0.02, height = 1,just = c("left", "top"),xscale=c(0,1),yscale = c(0,1)))
grid.draw(gb_p1);popViewport()
pushViewport(viewport(x = width.vector[1]+width.vector[2], y = 1, width = width.vector[3]-0.02, height = 1,just = c("left", "top"),xscale=c(0,1),yscale = c(0,1)))
grid.draw(gb_p2);popViewport()
?colorRamp2
if(is.null(sender.names)){sender.names=rownames(object@net[[1]])}
if(is.null(receiver.names)){receiver.names=colnames(object@net[[1]])}
## create Seurat object from NeuronChat object
meta <- data.frame(cell_subclass=object@data.signaling$cell_subclass)
rownames(meta) <- rownames(object@data.signaling)
seurat_VISp <- Seurat::CreateSeuratObject(counts = object@data, meta.data = meta)
seurat_VISp$groups <- meta$cell_subclass
SeuratObject::Idents(seurat_VISp) <- meta$cell_subclass
levels(seurat_VISp) <- sort(unique(c(sender.names,receiver.names)),method='radix')
## plot #1: heatmap
col_map = circlize::colorRamp2(c(0,max(object@net[[interaction_name]][sender.names,receiver.names])/2, max(object@net[[interaction_name]][sender.names,receiver.names])), c("blue", "white", "red"))
column_ha = HeatmapAnnotation(target = anno_barplot(object@target.abundance[receiver.names,interaction_name],border = F,height = unit(2,'cm'),gp = gpar(fill = "lightskyblue1")),annotation_name_side='left',annotation_name_rot = 0,annotation_label = 'target \n abundance')
row_ha = rowAnnotation(ligand = anno_barplot(object@ligand.abundance[sender.names,interaction_name],border = F,width = unit(2,'cm'),gp = gpar(fill = "lightskyblue1")),annotation_label = 'ligand \n abundance')
h1 <- ComplexHeatmap::Heatmap(object@net[[interaction_name]][sender.names,receiver.names], name = "Commu. \n Prob.", top_annotation = column_ha, right_annotation = row_ha,
cluster_rows = F,cluster_columns = F,column_names_rot=45,row_names_side = 'left',col = col_map,
column_title = 'Receiver',row_title = 'Sender',column_title_side = 'bottom',
heatmap_legend_param = list(color_bar='continuous'),show_row_dend = FALSE)
## plot #2: expression level for ligand related genes
if(length(object@DB[[interaction_name]]$lig_contributor)>1){
p1 <- Seurat::VlnPlot(subset(seurat_VISp, idents = sender.names),features = object@DB[[interaction_name]]$lig_contributor,group.by = 'cell_subclass',pt.size = 0,stack = T,flip = T)
p1$labels$title <- c('Ligand genes')} else {
p1 <- Seurat::VlnPlot(subset(seurat_VISp, idents = sender.names),features = object@DB[[interaction_name]]$lig_contributor,group.by = 'cell_subclass',pt.size = 0)+ theme(legend.position = 'none')
p1$labels$title <- paste('Ligand gene: ',p1$labels$title)
}
p1$theme$plot.title$hjust <- 0.5
## plot #3: expression level for ligand related genes
p2 <- Seurat::VlnPlot(subset(seurat_VISp, idents = receiver.names),features = object@DB[[interaction_name]]$receptor_subunit,group.by = 'cell_subclass',pt.size = 0) + theme(legend.position = 'none')
p2$labels$title <- paste('Target gene: ',p2$labels$title)
gb_h1 <- grid.grabExpr(draw(h1))
gb_p1 <- grid.grabExpr(print(p1))
gb_p2 <- grid.grabExpr(print(p2))
grid.newpage()
pushViewport(viewport(x = 0, y = 1, width = width.vector[1]-0.02, height =1, just = c("left", "top"),xscale=c(0,1),yscale = c(0,1)))
grid.draw(gb_h1);popViewport()
pushViewport(viewport(x = width.vector[1], y = 1, width = width.vector[2]-0.02, height = 1,just = c("left", "top"),xscale=c(0,1),yscale = c(0,1)))
grid.draw(gb_p1);popViewport()
pushViewport(viewport(x = width.vector[1]+width.vector[2], y = 1, width = width.vector[3]-0.02, height = 1,just = c("left", "top"),xscale=c(0,1),yscale = c(0,1)))
grid.draw(gb_p2);popViewport()
usethis::use_vignette("NeuronChat-tmp")
g1 <- rankNet_Neuron(x,slot.name = "net",measure = c("weight"),mode='single',font.size = 5)
g2 <- rankNet_Neuron(x,slot.name = "net",measure = c("count"),mode='single',font.size = 5)
g1+g2
## outgoing/incoming pattern
selectK_Neuron(x,pattern = "outgoing")
selectK_Neuron(x,pattern = "incoming")
x<- identifyCommunicationPatterns_Neuron(VISp[[1]], slot.name = "net", pattern = c("outgoing"), k=4,height = 18, thresh_quantile = 0)
x<- identifyCommunicationPatterns_Neuron(VISp[[1]], slot.name = "net", pattern = c("incoming"), k=4,height = 18)
netAnalysis_river_Neuron(VISp[[1]],slot.name = "net", pattern = c("outgoing"),font.size = 2.5,cutoff.1 = 0.5,cutoff.2=0.5,top.n1=1e4,top.n2=1e4)
netAnalysis_river_Neuron(VISp[[1]],slot.name = "net", pattern = c("incoming"),font.size = 2.5,cutoff.1 = 0.5,cutoff.2=0.5,top.n1=1e4,top.n2=1e4)
View(netAnalysis_river_Neuron)
library(NeuronChat)
x<- identifyCommunicationPatterns_Neuron(x, slot.name = "net", pattern = c("outgoing"), k=4,height = 18, thresh_quantile = 0)
x<- identifyCommunicationPatterns_Neuron(x, slot.name = "net", pattern = c("incoming"), k=4,height = 18)
netAnalysis_river_Neuron(x,slot.name = "net", pattern = c("outgoing"),font.size = 2.5,cutoff.1 = 0.5,cutoff.2=0.5)
library(ggalluvial)
netAnalysis_river_Neuron(x,slot.name = "net", pattern = c("outgoing"),font.size = 2.5,cutoff.1 = 0.5,cutoff.2=0.5)
netAnalysis_river_Neuron(x,slot.name = "net", pattern = c("incoming"),font.size = 2.5,cutoff.1 = 0.5,cutoff.2=0.5)
?identifyCommunicationPatterns_Neuron
x<- identifyCommunicationPatterns_Neuron(x, slot.name = "net", pattern = c("outgoing"), k=4,height = 18)
x<- identifyCommunicationPatterns_Neuron(x, slot.name = "net", pattern = c("incoming"), k=3,height = 18)
library(ggalluvial)
netAnalysis_river_Neuron(x,slot.name = "net", pattern = c("outgoing"),font.size = 2.5,cutoff.1 = 0.5,cutoff.2=0.5)
netAnalysis_river_Neuron(x,slot.name = "net", pattern = c("incoming"),font.size = 2.5,cutoff.1 = 0.5,cutoff.2=0.5)
View(netAnalysis_river)
x<- identifyCommunicationPatterns_Neuron(x, slot.name = "net", pattern = c("outgoing"), k=4,height = 18)
x<- identifyCommunicationPatterns_Neuron(x, slot.name = "net", pattern = c("incoming"), k=5,height = 18)
library(ggalluvial)
netAnalysis_river_Neuron(x,slot.name = "net", pattern = c("outgoing"),font.size = 2.5,cutoff.1 = 0.5,cutoff.2=0.5)
netAnalysis_river_Neuron(x,slot.name = "net", pattern = c("incoming"),font.size = 2.5,cutoff.1 = 0.5,cutoff.2=0.5)
x<- identifyCommunicationPatterns_Neuron(x, slot.name = "net", pattern = c("outgoing"), k=4,height = 18)
x<- identifyCommunicationPatterns_Neuron(x, slot.name = "net", pattern = c("incoming"), k=5,height = 18)
library(ggalluvial)
netAnalysis_river_Neuron(x,slot.name = "net", pattern = c("outgoing"),font.size = 2.5,cutoff.1 = 0.5,cutoff.2=0.5,top.n2 = 50)
netAnalysis_river_Neuron(x,slot.name = "net", pattern = c("incoming"),font.size = 2.5,cutoff.1 = 0.5,cutoff.2=0.5,top.n2 = 50)
netAnalysis_river_Neuron(x,slot.name = "net", pattern = c("incoming"),font.size = 2.5,cutoff.1 = 0.5,cutoff.2=0.5,top.n2 = 20)
x<- identifyCommunicationPatterns_Neuron(x, slot.name = "net", pattern = c("outgoing"), k=4,height = 18)
x<- identifyCommunicationPatterns_Neuron(x, slot.name = "net", pattern = c("incoming"), k=4,height = 18)
library(ggalluvial)
netAnalysis_river_Neuron(x,slot.name = "net", pattern = c("outgoing"),font.size = 2.5,cutoff.1 = 0.5,cutoff.2=0.5,top.n2 = 50)
netAnalysis_river_Neuron(x,slot.name = "net", pattern = c("incoming"),font.size = 2.5,cutoff.1 = 0.5,cutoff.2=0.5,top.n2 = 20)
netAnalysis_river_Neuron(x,slot.name = "net", pattern = c("outgoing"),font.size = 2.5,cutoff.1 = 0.5,cutoff.2=0.5)
netAnalysis_river_Neuron(x,slot.name = "net", pattern = c("incoming"),font.size = 2.5,cutoff.1 = 0.5,cutoff.2=0.5)
x <- computeNetSimilarity_Neuron(VISp[[1]],type='functional')
x <- computeNetSimilarity_Neuron(x,type='functional')
x  <- netEmbedding(x, slot.name = "net_analysis", type = "functional")
x <- netClustering(x, type='functional',slot.name = "net_analysis",k=5)
netVisual_embedding_Neuron(x, type = "functional", label.size = 5,pathway.remove.show = F)
netVisual_embeddingZoomIn_Neuron(x, type = "functional", nCol = 2,label.size = 3)
library(CellChat)
use_readme_rmd(open = rlang::is_interactive())
usethis::use_readme_md(open = rlang::is_interactive())
